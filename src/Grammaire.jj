/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = false;
  debug_parser = false;}PARSER_BEGIN(Grammaire)
import java.io.*;
import ast.*;
import java.util.Stack;
import java.util.ArrayList;
import java.util.List;
import java.lang.Math;
import java.util.Random;

public class Grammaire{

  static Object[][] myArray;
  static Stack stack = new Stack();
  static int uniqueID = 0;



  public static Object[][] DataGenerator(Function myFunction) 
  {
    int max =  10000; 
    int min = -10000; 
    int range = max - min + 1;
    
	String type = "";
	
	int qty = myFunction.getParameter_declaration_list().size();
	int ctr = 0;	
	Object[][] tmpArray = new Object[qty][10];
	
    for(Parameter_declaration pd : myFunction.getParameter_declaration_list())
    {
    	type = pd.getType();
    	
    	if(type.equals("int"))
    	{
    	  int random_int;
    	  for (int i = 0; i < 10; i++)
    	  { 
            	random_int = (int)(Math.random() * range) + min;
				tmpArray[ctr][i] = random_int;
		  }
    	  		
    	  
    	}else if(type.equals("double"))
    	{
    	  double random_double;
    	  for (int i = 0; i < 10; i++)
    	  { 
            	random_double = (double)(Math.random() * range) + min;
            	tmpArray[ctr][i] = random_double;
		  }
    	  
    	}else if(type.equals("bool"))
    	{
    	  for (int i = 0; i < 10; i++)
    	  { 
		    	Random r = new Random();
		    	tmpArray[ctr][i] = r.nextBoolean();
		  }
    	}


    	ctr++;
    }

    return tmpArray;
  }
  
  public static void main(String args []) throws ParseException  {    
    try {      
	    InputStream inputStream = new FileInputStream(new File("test.txt"));	    Grammaire parser = new Grammaire(inputStream);
	    parser.function();

		//System.out.println(stack.peek());





		Function myFunction = (Function)stack.peek();
		myArray = DataGenerator(myFunction);

	

		

		

	    
 	 } catch(IOException exception) {
		exception.printStackTrace();
 	 }  }}PARSER_END(Grammaire)
SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

MORE :
{
	"//" : IN_SINGLE_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT>
MORE :
{
  < ~[] >
}
TOKEN : /* OPERATEURS */{
  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >
| < MODULO : "%" >
| < ASSIGN : "=" >
| < EQUAL : "==" >
| < NOT_EQUAL : "<>" >
| < GREATER : ">" >
| < GREATER_OR_EQUAL : ">=" >
| < LOWER : "<" >
| < LOWER_OR_EQUAL : "<=" >
| < AND : "&&" >
| < OR : "||" >
| < NOT : "!" >
| < PREFIX_INCREMENT : "++" >
| < PREFIX_DECREMENT : "--" >}

TOKEN : /* MOTS CLÉS */
{
  < IF : "if" >
| < ELSE : "else" >
| < WHILE : "while" >
| < FOR : "for" > // A RETIRER
| < TRUE: "TRUE" >
| < FALSE : "FALSE" >
| < RETURN : "return" >
| < NEW : "new" >
}

TOKEN : /* TYPES */
{  < INTEGER_TYPE : "int" >
| < DECIMAL_TYPE : "double" >
| < BOOLEAN : "bool" >
| < VOID : "void" >
}TOKEN :	/* LITTERAUX */{
  < #DIGIT: ["0"-"9"] >
| < #LETTER : ["A"-"Z", "a" - "z"] >
| < INTEGER : ("-")? ( < DIGIT > )+ >
| < DECIMAL :
		("-")? (< DIGIT >)+ "." (< DIGIT >)*
	|  	("-")? (< DIGIT >)* "." (< DIGIT >)+
	>
| < IDENTIFIER : < LETTER > (< LETTER > | < DIGIT >)* >}

void function() :
{
  Token ident = null;
  Token f_type = null;
}
{
	(
		f_type = type() | f_type = < VOID > 
	)
	ident = < IDENTIFIER >
	{
	  Function func = new Function(f_type.toString() , ident.toString());
	  stack.push(func);
	}
	"(" (parameter_declaration() ("," parameter_declaration())*)? ")" "{"
		function_body()
	"}"

	{
	  Function_body funcB = (Function_body)stack.pop();
	  func.setFunction_body(funcB);
	  
	  func.accept(new VisitorPrint());
	}
	
	(function())*
	< EOF >
}

void parameter_declaration():
{
    Token ident = null;
    Token type = null;
}
{

	{
	  Parameter_declaration myParameter_declaration = new Parameter_declaration();
	}
  
	type = type() ident = < IDENTIFIER >
	
	{
		myParameter_declaration.setParameter_name(ident.toString());
		myParameter_declaration.setType(type.toString());

		Function func = (Function)stack.peek();
		List<Parameter_declaration> parameter_declaration_list = func.getParameter_declaration_list();
		parameter_declaration_list.add(myParameter_declaration);
		
		func.setParameter_declaration_list(parameter_declaration_list);
	}
}

void function_body() :
{
}
{
	{
	    Function_body myFunction_body = new Function_body();

	  	VariableDeclarationList myVariableDeclarationList = new VariableDeclarationList();	}
	
    ( variable_declaration() ";"
	{
		Variable_declaration varD = (Variable_declaration)stack.pop();
		myVariableDeclarationList.add(varD);
	}
    )*
	{
	    myFunction_body.setVariable_declaration_list(myVariableDeclarationList);
	
	   	StatementList myStatementList = new StatementList();
	}
  	( statement()
	{
		Statement statement = (Statement)stack.pop();
	  	myStatementList.add(statement);
	}
  	)*
  	{
		myFunction_body.setStatement_list(myStatementList);
	}
	( return_statement()
	{
	  	Return_statement rStatement = (Return_statement)stack.pop();
	  	myFunction_body.setReturn_statement(rStatement);
	}
	)?

	{
		stack.push(myFunction_body);
	}}
void statement() :
{		
}
{
	{
		Statement myStatement = new Statement();
		stack.push(myStatement);
	}
	(		(
			LOOKAHEAD(2)			assignment()
			{
			   Assignment myAssignment = (Assignment)stack.pop();
			   myStatement = (Statement)stack.peek();
			   myStatement.setAssignment(myAssignment);
			  
			}
			| function_call()
		) ";"
		| conditional_statement()	
		| while_loop()
		| for_loop()
	)

	{
		myStatement = (Statement)stack.pop();
		StatementList myStatementList = (StatementList)stack.peek();
		myStatementList.add(myStatement);
	}

}

void variable_declaration():
{
  Token t = null;
}
{
  	{
		Variable_declaration myVariable_declaration = new Variable_declaration();

		AssignmentList myAssignmentList = new AssignmentList();
		stack.push(myAssignmentList);
	}
	t = type() assignment()
	{
		Assignment myAssignment = (Assignment)stack.pop();
		myAssignmentList = (AssignmentList)stack.peek();
	  	myAssignmentList.add(myAssignment); 
	}
	("," assignment()
	{
	  	myAssignment = (Assignment)stack.pop();
		myAssignmentList = (AssignmentList)stack.peek();
	  	myAssignmentList.add(myAssignment); 
	}
	)*
	{
		myAssignmentList = (AssignmentList)stack.pop();
		
		myVariable_declaration.setAssignment_list(myAssignmentList);
		myVariable_declaration.setType(t.toString());
		
		stack.push(myVariable_declaration);
	}
}

Token litteral_value() :
{
  Token t = null;
}
{
	(		t = < INTEGER >
		| t = < DECIMAL >
		| boolean_value()
	)
	{
  			  return t;
	}	
}

void boolean_value() :
{
}
{
	( < TRUE > | < FALSE > )
}

Token type() :
{
  Token tok=null;
}
{
	(
		
		tok = < INTEGER_TYPE >
		| tok = < DECIMAL_TYPE >
		| tok = < BOOLEAN >
	)

	{
	  return tok;
	}
}

void conditional_statement():
{
}
{
	< IF > "("
	{
	  Conditional_statement myConditional_statement = new Conditional_statement();
	}
	 expression()	")"
	{
		Expression exp = (Expression)stack.pop();
		myConditional_statement.setExpression(exp);  
	}
	"{" (
	     statement()

	     )*
	( LOOKAHEAD(2) "}" < ELSE > "{" ( statement() )* )?

	 "}"

	{
		
		stack.push(myConditional_statement);
	  	int i = 0;
		/*node = (ASTNode)stack.peek();
		Expression myExpression;
		if(node instanceof StatementList)
		{
		  	StatementList myStateList = (StatementList)stack.pop();
		
		  	node = (ASTNode)stack.peek();
		  	if(node instanceof Expression)
		  	{
		  	  	myExpression = (Expression)stack.pop();
		  	  	myConditional_statement = (Conditional_statement)stack.pop();
		  	  	myConditional_statement.setStatement_list(myStateList);
		  	  	Statement myStatement = (Statement)stack.peek();
				myStatement.setConditional_statement(myConditional_statement);
		  	}else
		  	{
		  	  	myConditional_statement = (Conditional_statement)stack.pop();
				myConditional_statement.setStatement_list(myStateList);
		
				Statement myStatement = (Statement)stack.peek();
				myStatement.setConditional_statement(myConditional_statement);
		  	}
		}else if(node instanceof Expression)
		{
		  	myExpression = (Expression)stack.pop();
		  	myConditional_statement = (Conditional_statement)stack.pop();
			Statement myStatement = (Statement)stack.peek();
			myConditional_statement.setExpression(myExpression);
			myStatement.setConditional_statement(myConditional_statement);
		  	
		}else if(node instanceof Conditional_statement)
		{
			myConditional_statement = (Conditional_statement)stack.pop();
			Statement myStatement = (Statement)stack.peek();
			myStatement.setConditional_statement(myConditional_statement);
		}else if(node instanceof Statement)
		{
		  	Statement myStatement = (Statement)stack.peek();
		    myStatement.setConditional_statement(myConditional_statement);
		}*/
	}

}

void expression():
{
  	LogExpression lExp = new LogExpression();
  	Expression exp;
}
{
 	comparaison_expression() // A > B
 	(
		{
	 	   exp = (Expression)stack.pop();
	 	   lExp.setGauche(exp);
	 	}
		
	 	logical_connector()
	 	{
			Logical_connector lCon = (Logical_connector)stack.pop();
			lExp.setLogical_connector(lCon);	
	 	}
	 	
	 	comparaison_expression()
		{
	  		exp = (Expression)stack.pop();
	 	  	lExp.setDroite(exp);
	 	  	stack.push(lExp);
		}

 	 )* // (a > b) || (b > a)
}

void comparaison_expression():
{
  	Comparaison_expression myComparaison_expression = new Comparaison_expression();
}
{
	 arithmetic_expression_priority_low() // a ou a+b ou a-b ou a*b ou a/b
	 (
	  	{ 	  
	  	    Expression expGauche = (Expression)stack.pop();
	  		myComparaison_expression.setGauche(expGauche);
		}
		
	   	comparaison_operator()
	   	{
	     	Comparaison_operator operator = (Comparaison_operator)stack.pop();
	     	myComparaison_expression.setComparaison_operator(operator);
	   	}
	   	
	   	arithmetic_expression_priority_low() // a > b ou a+b < a/b etc.
		{
			Expression expDroite = (Expression)stack.pop();		
	   		myComparaison_expression.setDroite(expDroite);
	   		stack.push(myComparaison_expression);  
		}
	 )*
}


void arithmetic_expression_priority_low():
{
}
{
  	 /*{
  		Arithmetic_expression_priority_low myArithmetic_expression_priority_low = new Arithmetic_expression_priority_low ();
		stack.push(myArithmetic_expression_priority_low);
	 }*/
	 
	 arithmetic_expression() // a/b ou a*b ou a
	 (
	    {
  			Arithmetic_expression_priority_low myArithmetic_expression_priority_low = new Arithmetic_expression_priority_low ();
			stack.push(myArithmetic_expression_priority_low);
	    }
	    
	   	arithmetic_operation_piority_low() arithmetic_expression() // a/b + a*b ou a/b - a*b

	   {
  		myArithmetic_expression_priority_low = (Arithmetic_expression_priority_low)stack.pop();
		Comparaison_expression myComparaison_expression = (Comparaison_expression)stack.peek();
		myComparaison_expression.setDroite(myArithmetic_expression_priority_low);	
	 	}

	 )*

	 /*{
  		myArithmetic_expression_priority_low = (Arithmetic_expression_priority_low)stack.pop();
  		Comparaison_expression myComparaison_expression = (Comparaison_expression)stack.peek();
  		List<Arithmetic_expression_priority_low> arithmetic_expression_priority_lowList = myComparaison_expression.getArithmetic_expression_priority_lowList();
  		arithmetic_expression_priority_lowList.add(myArithmetic_expression_priority_low);
  		myComparaison_expression.setArithmetic_expression_priority_lowList(arithmetic_expression_priority_lowList);
	 }*/
}

void arithmetic_expression():
{
}
{
   	/*{
  		Arithmetic_expression myArithmetic_expression = new Arithmetic_expression ();
		stack.push(myArithmetic_expression);
	}*/
	
	unary_expression() // a
	(
	    {
  		Arithmetic_expression myArithmetic_expression = new Arithmetic_expression ();
		stack.push(myArithmetic_expression);
	    }
	    
	  	arithmetic_operation() unary_expression() // a/b ou a*b
	  	
	  	{
  		myArithmetic_expression = (Arithmetic_expression)stack.pop();
		Arithmetic_expression_priority_low myArithmetic_expression_priority_low = (Arithmetic_expression_priority_low)stack.peek();
		myArithmetic_expression_priority_low.setDroite(myArithmetic_expression);	
	 	}
	)*

	/*{
  		myArithmetic_expression = (Arithmetic_expression)stack.pop();
  		Arithmetic_expression_priority_low myArithmetic_expression_priority_low = (Arithmetic_expression_priority_low)stack.peek();
  		List<Arithmetic_expression> arithmetic_expressionList = myArithmetic_expression_priority_low.getArithmetic_expressionList();
  		arithmetic_expressionList.add(myArithmetic_expression);
  		myArithmetic_expression_priority_low.setArithmetic_expressionList(arithmetic_expressionList);
	}*/
}

void unary_expression():
{
}
{

	
	(unary_operator() // a++ ou a-- ou !a
	{
  		Unary_expression myUnary_expression = new Unary_expression();
		stack.push(myUnary_expression);
	}
	)? term() // a

	{
	}
}

void term():
{
}
{
    {
  		Term myTerm = new Term ();
	}
	
	value()
	
	{
		Value val = (Value)stack.pop();
		myTerm.setValue(val);
		stack.push(myTerm);
	}
	| "(" expression()
		{

		//ICI	  
			/*Expression myExpression = new Expression();
			Term myTerm = new Term();

			ASTNode node = (ASTNode)stack.peek();

			if(node instanceof Expression)
			{
				myExpression = (Expression)stack.pop();
			}else
			{
				myTerm = (Term)stack.pop();
				myExpression = myTerm.getExpression();
			}

			node = (ASTNode)stack.peek();
			if(node instanceof Term)
			{
			  	myTerm = (Term)stack.peek();
			}else
			{
		    	myTerm = new Term();
		      	stack.push(myTerm);
			}
			  
			 myTerm = (Term)stack.peek();
			 myTerm.setExpression(myExpression);
			
			 /*	 myTerm = (Term)stack.pop();
	  		 myUnary_expression = (Unary_expression)stack.peek();
			 myUnary_expression.setTerm(myTerm);*/
		}
	")"


}

void unary_operator():
{
  Token t = null;
}
{
    {
  		Unary_operator myUnary_operator = new Unary_operator ();
		stack.push(myUnary_operator);
	}
	(		t = < PREFIX_INCREMENT >
		| t = < PREFIX_DECREMENT >
		| t = < NOT >
	)
	{
  		myUnary_operator = (Unary_operator)stack.pop();
  		myUnary_operator.setOperator(t.toString());
  		Unary_expression myUnary_expression = (Unary_expression)stack.peek();
		myUnary_expression.setUnary_operator(myUnary_operator);
	}
}

void value():
{
  Token t = null ;
}
{
	{
  		Value myValue = new Value();
	}


  
	( 
		LOOKAHEAD(2) function_call()
		| t = < IDENTIFIER >
		| t = litteral_value()
	)


	{			  
		myValue.setIdentificateur(t.toString());
		stack.push(myValue);
	}	
}

void arithmetic_operation():
{
  Token t = null;
}
{
  	{
  	    Arithmetic_operation myArithmetic_operation = new Arithmetic_operation();
		stack.push(myArithmetic_operation);
	}
	
	( t = < MULTIPLY > | t = < DIVIDE > | t = < MODULO > )
	
	{
		myArithmetic_operation = (Arithmetic_operation)stack.pop();
		myArithmetic_operation.setOperation(t.toString());	
  		Arithmetic_expression myArithmetic_expression = (Arithmetic_expression)stack.peek();
  		List<Arithmetic_operation> Arithmetic_operationList = myArithmetic_expression.getArithmetic_operationList(); 		
  		Arithmetic_operationList.add(myArithmetic_operation);		
  		myArithmetic_expression.setArithmetic_operationList(Arithmetic_operationList);
	}
}

void arithmetic_operation_piority_low():
{
    Token t = null;
}
{
    {
  	    Arithmetic_operation_piority_low myArithmetic_operation_piority_low = new Arithmetic_operation_piority_low();
		stack.push(myArithmetic_operation_piority_low);
	}
	
	( t = < PLUS > | t = < MINUS > )

	{
		myArithmetic_operation_piority_low = (Arithmetic_operation_piority_low)stack.pop();
		myArithmetic_operation_piority_low.setOperation(t.toString());		
  		Arithmetic_expression_priority_low myArithmetic_expression_priority_low = (Arithmetic_expression_priority_low)stack.peek();		
  		List<Arithmetic_operation_piority_low> Arithmetic_operation_piority_lowList = myArithmetic_expression_priority_low.getArithmetic_operation_priority_lowList();
  		 		
  		Arithmetic_operation_piority_lowList.add(myArithmetic_operation_piority_low);		
  		myArithmetic_expression_priority_low.setArithmetic_operation_piority_lowList(Arithmetic_operation_priority_lowList);
	}
}

void comparaison_operator():
{
  	Token comp_operator=null;
}
{

 	{
  		Comparaison_operator myOperator = new Comparaison_operator();
	}
	
  	(comp_operator= < EQUAL > | comp_operator= < NOT_EQUAL > | comp_operator= < GREATER > | comp_operator = < GREATER_OR_EQUAL > | comp_operator = < LOWER > | comp_operator= < LOWER_OR_EQUAL > )
  	
  	{
				myOperator.setComparaison_operator(comp_operator.toString());
				stack.push(myOperator);
  	}
}

void logical_connector():
{
  Token t = null;
}
{
  	 {
	   Logical_connector myLogical_connector = new Logical_connector();
	   stack.push(myLogical_connector);
	 }
	    ( t = < AND > | t = < OR > )
	 {
	   myLogical_connector = (Logical_connector)stack.pop();
	   myLogical_connector.setConnector(t.toString());
	   Expression myExpression = (Expression)stack.peek();
	   //myExpression.setLogical_connector(myLogical_connector);	
	 }
}

void function_call():
{
}
{
	< IDENTIFIER > "(" (expression() ("," expression())*)* ")"
}

void assignment():
{
  Token identifier = null;
  Token assign = null;
  
}
{
	{
	  Assignment myAssignment = new Assignment();
	}
    identifier = < IDENTIFIER > assign = < ASSIGN > expression()
    {
      Expression myExpr = (Expression)stack.pop();
            
      myAssignment.setIdentifier(identifier.toString());
      myAssignment.setAssign(assign.toString());
	  myAssignment.setExpr(myExpr);

	  stack.push(myAssignment);
	}
}

void while_loop():
{
}
{
	< WHILE > "(" expression() ")" "{" (statement())* "}"
}

void for_loop():
{
}
{
	< FOR > "(" (assignment())? ";" (expression())? ";" (assignment())?  ")" "{" (statement())* "}"
}

void return_statement():
{
 	Return_statement rStatement = new Return_statement();
}
{
	< RETURN > expression() ";"
	{
		Expression exp = (Expression)stack.pop();
		rStatement.setExpression(exp);
		stack.push(rStatement);
		
	}
}