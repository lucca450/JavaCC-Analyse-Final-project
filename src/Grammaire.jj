/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = false;
  debug_parser = false;}PARSER_BEGIN(Grammaire)
import java.io.*;
import ast.*;
import java.util.Stack;
import java.util.ArrayList;
import java.util.List;

public class Grammaire{

  static Stack stack = new Stack();
  static int uniqueID = 0;
  
  
  public static void main(String args []) throws ParseException  {    
    try {      
	    InputStream inputStream = new FileInputStream(new File("test.txt"));	    Grammaire parser = new Grammaire(inputStream);
	    parser.function();



		/*System.out.println("yo");
		stack.push("bot");
		stack.push("mid");
		stack.push("top");*/
		//System.out.println(stack.peek());


			  System.out.println(stack.peek());

	    
 	 } catch(IOException exception) {
		exception.printStackTrace();
 	 }  }}PARSER_END(Grammaire)
SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

MORE :
{
	"//" : IN_SINGLE_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT>
MORE :
{
  < ~[] >
}
TOKEN : /* OPERATEURS */{
  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >
| < MODULO : "%" >
| < ASSIGN : "=" >
| < EQUAL : "==" >
| < NOT_EQUAL : "<>" >
| < GREATER : ">" >
| < GREATER_OR_EQUAL : ">=" >
| < LOWER : "<" >
| < LOWER_OR_EQUAL : "<=" >
| < AND : "&&" >
| < OR : "||" >
| < NOT : "!" >
| < PREFIX_INCREMENT : "++" >
| < PREFIX_DECREMENT : "--" >}

TOKEN : /* MOTS CLÉS */
{
  < IF : "if" >
| < ELSE : "else" >
| < WHILE : "while" >
| < FOR : "for" > // A RETIRER
| < TRUE: "TRUE" >
| < FALSE : "FALSE" >
| < RETURN : "return" >
| < NEW : "new" >
}

TOKEN : /* TYPES */
{  < INTEGER_TYPE : "int" >
| < DECIMAL_TYPE : "double" >
| < BOOLEAN : "bool" >
| < VOID : "void" >
}TOKEN :	/* LITTERAUX */{
  < #DIGIT: ["0"-"9"] >
| < #LETTER : ["A"-"Z", "a" - "z"] >
| < INTEGER : ("-")? ( < DIGIT > )+ >
| < DECIMAL :
		("-")? (< DIGIT >)+ "." (< DIGIT >)*
	|  	("-")? (< DIGIT >)* "." (< DIGIT >)+
	>
| < IDENTIFIER : < LETTER > (< LETTER > | < DIGIT >)* >}

void function() :
{
  Token ident = null;
  Token f_type = null;
}
{
	(
		f_type = type() | f_type = < VOID > 
	)
	ident = < IDENTIFIER >
	{
	  stack.push(new Function(f_type.toString() , ident.toString()));
	  Function myFunction = (Function)stack.peek();
	}
	"(" (parameter_declaration() ("," parameter_declaration())*)? ")" "{"
		function_body()
	"}"

	{
	  myFunction.accept(new VisitorPrint(0));
	}
	
	(function())*
	< EOF >
}

void parameter_declaration():
{
    Token ident = null;
    Token type = null;
}
{

	{
	  Parameter_declaration myParameter_declaration = new Parameter_declaration();
	  stack.push(myParameter_declaration);
	}
  
	type = type() ident = < IDENTIFIER >
	
	{
		myParameter_declaration = (Parameter_declaration)stack.pop();
		myParameter_declaration.setParameter_name(ident.toString());
		myParameter_declaration.setType(type.toString());
			
		Function myFunction = (Function)stack.peek();

		List<Parameter_declaration> parameter_declaration_list = myFunction.getParameter_declaration_list();
		parameter_declaration_list.add(myParameter_declaration);
		
		myFunction.setParameter_declaration_list(parameter_declaration_list);
	}
}

void function_body() :
{
}
{
	{
	    Function_body myFunction_body = new Function_body();
	  	stack.push(myFunction_body);
	  	StatementList myStatementList = new StatementList();
	  	stack.push(myStatementList);	}
	
    ( variable_declaration() ";" )*
  	( statement() )*
	( return_statement() )?
	
		{
		    myStatementList = (StatementList)stack.pop();
			myFunction_body = (Function_body)stack.pop();
			myFunction_body.setStatement_list(myStatementList);
			Function myFunction = (Function)stack.peek();
			myFunction.setFunction_body(myFunction_body);
		}}
void statement() :
{		
}
{
	{
		Statement myStatement = new Statement();
		stack.push(myStatement);
	}
	(		(
			LOOKAHEAD(2)			assignment() | function_call()
		) ";"
		| conditional_statement()
		| while_loop()
		| for_loop()
	)


	{
		myStatement = (Statement)stack.pop();
		StatementList myStatementList = (StatementList)stack.peek();
		myStatementList.add(myStatement);
	}

}

void variable_declaration():
{
}
{
	type() assignment()	("," assignment() )*
}

Token litteral_value() :
{
  Token t = null;
}
{
	(		t = < INTEGER >
		| t = < DECIMAL >
		| boolean_value()
	)
	{
  			  return t;
	}	
}

void boolean_value() :
{
}
{
	( < TRUE > | < FALSE > )
}

Token type() :
{
  Token tok=null;
}
{
	(
		
		tok = < INTEGER_TYPE >
		| tok = < DECIMAL_TYPE >
		| tok = < BOOLEAN >
	)

	{
	  return tok;
	}
}

void conditional_statement():
{
}
{

	{
	  Conditional_statement myConditional_statement = new Conditional_statement();
	  stack.push(myConditional_statement);
	}

	< IF > "(" expression()	")"
	{
	  StatementList myStatementList = new StatementList();
	  stack.push(myStatementList);
	}
	"{" ( statement() )*
	( LOOKAHEAD(2) "}" < ELSE > "{" ( statement() )* )? "}"

	 {

 			myStatementList = (StatementList)stack.pop();
			myConditional_statement = (Conditional_statement)stack.pop();
			myConditional_statement.setStatement_list(myStatementList);
			Statement myStatement = (Statement)stack.peek();
			myStatement.setConditional_statement(myConditional_statement);

	 }
}

void expression():
{
}
{

   	{
   	  Expression myExpression = new Expression();
	  stack.push(myExpression);
	}
	  
 	comparaison_expression() ( logical_connector() comparaison_expression() )*


 	 {
		myExpression = (Expression)stack.pop();

		Conditional_statement myConditional_statement = (Conditional_statement)stack.peek();
		myConditional_statement.setExpression(myExpression);
	 }
}

void comparaison_expression():
{
}
{


  	{
  		Comparaison_expression myComparaison_expression = new Comparaison_expression();
		stack.push(myComparaison_expression);
	}
	
	 arithmetic_expression_priority_low() ( comparaison_operator() arithmetic_expression_priority_low() )*
	 
	 {
	   	myComparaison_expression = (Comparaison_expression)stack.pop();	
		Expression myExpression = (Expression)stack.peek();
		myExpression.setComparaison_expression(myComparaison_expression);		
	 }
}


void arithmetic_expression_priority_low():
{
}
{
	arithmetic_expression() ( arithmetic_operation_piority_low() arithmetic_expression() )*
}

void arithmetic_expression():
{
}
{ 
	unary_expression() ( arithmetic_operation() unary_expression() )*
}

void unary_expression():
{
}
{
	( unary_operator() )? term()
}

void term():
{
}
{
	value() | "(" expression() ")"
}

void unary_operator():
{
}
{
	(		< PREFIX_INCREMENT >
		| < PREFIX_DECREMENT >
		| < NOT >
	)
}

void value():
{
  Token t = null ;
}
{
	{
  		Value myValue = new Value();
  		stack.push(myValue);
	}


  
	( 
		LOOKAHEAD(2) function_call()
		| t = < IDENTIFIER >
		| t = litteral_value()
	)


	{

				myValue = (Value)stack.pop();
				Comparaison_expression myComparaison_expression = (Comparaison_expression)stack.peek();
				
					    if(myComparaison_expression.getValue() == null)
					    {
					      		 myValue.setIdentificateur(t.toString());
					      		 //myValue.setType();
					     		 myComparaison_expression.setValue(myValue);
					    }
					    else if(myComparaison_expression.getValue2() == null)
					    {
					      		 myValue.setIdentificateur(t.toString());
					      		 //myValue.setType();
					     		 myComparaison_expression.setValue2(myValue);
					  	}  	
	}	
}

void arithmetic_operation():
{
}
{
	( < MULTIPLY > | < DIVIDE > | < MODULO > )
}

void arithmetic_operation_piority_low():
{
}
{
	( < PLUS > | < MINUS > )
}

void comparaison_operator():
{
  Token comp_operator=null;
}
{

 	{
  		Comparaison_operator myOperator = new Comparaison_operator();
  		stack.push(myOperator);
	}
	
  	(comp_operator= < EQUAL > | comp_operator= < NOT_EQUAL > | comp_operator= < GREATER > | comp_operator = < GREATER_OR_EQUAL > | comp_operator = < LOWER > | comp_operator= < LOWER_OR_EQUAL > 	)
  	
  	{
				myOperator = (Comparaison_operator)stack.pop();
				Comparaison_expression myComparaison_expression = (Comparaison_expression)stack.peek();

				myOperator.setComparaison_operator(comp_operator.toString());
				myComparaison_expression.setComparaison_operator(myOperator);
  	}
}

void logical_connector():
{
}
{
	( < AND > | < OR > )
}

void function_call():
{
}
{
	< IDENTIFIER > "(" (expression() ("," expression())*)* ")"
}

void assignment():
{
}
{
 
    < IDENTIFIER > < ASSIGN > expression()
}

void while_loop():
{
}
{
	< WHILE > "(" expression() ")" "{" (statement())* "}"
}

void for_loop():
{
}
{
	< FOR > "(" (assignment())? ";" (expression())? ";" (assignment())?  ")" "{" (statement())* "}"
}

void return_statement():
{
}
{
	< RETURN > expression() ";"
}